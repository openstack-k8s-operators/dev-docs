# TLS

Certificate management within the openstack-operator is by default done using [cert-manager](https://cert-manager.io/docs/). For each component the openstack-operator creates one or multiple certificates and pass the name/names of the k8s secret, which contains the certificate, key and ca certificate, to the service component. By default cert-manager does not delete k8s secrets, holding the certificate information, when the cert-manager certificate resource gets deleted. Consult the OpenShift documentation on [Deleting a TLS secret automatically upon Certificate removal](https://docs.openshift.com/container-platform/4.14/security/cert_manager_operator/cert-manager-customizing-api-fields.html#cert-manager-override-flag-controller_cert-manager-customizing-api-fields).

In the context of TLS (Transport Layer Security) configuration within the OpenStackControlPlane, two primary levels of traffic encryption are distinguished: `ingress` and `podLevel`:
* `ingress` refers to the public (external) traffic that enters the cluster via a route
* `podLevel` refers to the internal traffic within the cluster, specifically, the communication between pods, services and edpm nodes.

TLS is enabled by default for both `ingress` and `podLevel` communication.

## Endpoint Termination overview
In terms of how traffic is managed within the cluster:
* Public Endpoints
  * Public (external) endpoints are by default terminated at the route. The openstack-operator is responsible for creating these routes for each of the services
  * Using the `serviceOverride` it is possible to use a `LoadBalancer` service for public endpoints as well.
* Internal Endpoints
  * Internal endpoints terminate at the designated service, this can be either `ClusterIP` or `LoadBalancer` type of service (e.g. MetalLB).

More details on networking check [Networking](./networking.md)

## General TLS control
The default TLS settings can be changed using the `tls` section of the `OpenStackControlPlane`:

Example of a basic TLS section:
```yaml
apiVersion: core.openstack.org/v1beta1
kind: OpenStackControlPlane
metadata:
  name: myctlplane
spec:
  tls:
    ingress:
      enabled: true
    podLevel:
      enabled: false
    caBundleSecretName: myAdditionalCACerts
```

## TLS Certificates

### CA Certificates

By default, the openstack-operator provisions the following CAs via cert-manager for securing endpoints:
* rootca-public - used to issue certificates for routes and k8s services for public endpoint httpd vhost configuration.
* rootca-internal - used to issue certificates for all internal communication, like internal endpoint httpd vhost config, database, rabbitmq ..., except of the bellow special use case CAs.
* rootca-ovn - used to issue certificates for ovn/ovs services specifically.
* rootca-libvirt - used to issue certificates for libvirt/qemu services specifically.

By default CA certificates are valid for 10 years and service certificates for 5. This can be customized using the `duration` and `renewBefore` parameters for CA and certificates, e.g.:

```yaml
spec:
  tls:
    ingress:
      ca:
        duration: 43800h
      cert:
        duration: 5000h
        renewBefore: 100h
      enabled: true
    podLevel:
      enabled: true
      internal:
        ca:
          duration: 43800h
        cert:
          duration: 5000h
          renewBefore: 200h
      libvirt:
        ca:
          duration: 83800h
        cert:
          duration: 5000h
      ovn:
        ca:
          duration: 83800h
        cert:
          duration: 5000h
```

#### Combined CA Bundle

The combined-ca-bundle secret, generated by the openstack-operator, aggregates:
* System default CAs,
* Operator-created CAs,
* Third-party CAs provided with `tls.caBundleSecretName`.
This bundle ensures a trusted CA pool is available for all services, supporting both default and custom certificate validation. The bundle can be used to be direct mounted into a deployment to the environment wide CA location. The [lib-common common module tls package](https://github.com/openstack-k8s-operators/lib-common/tree/main/modules/common/tls) provides funtionality for this.

The secret also has a default label which can be used to query:
```yaml
  labels:
    combined-ca-bundle: ""
```

Using the `caBundleSecretName` parameter a secret can be referenced containing any additional CA certificates, which should be added to the CA bundle.

Whenever `openstack-operator` reconciles it will check for expired or new CA certs to be added to the bundle. Not expired CAs will be kept in the secret if they are not yet expired, even if they got removed from the source it was originally taken from. This allows to rotate certs for a service using a new CA.

Note: The CA provided via the `apiOverride.route` is right now *not* added to the CA bundle.

### Service Certificates for Public and Internal Endpoints

Certificates for both public and internal service endpoints are automatically managed by cert-manager, but can be customized for specific requirements.

#### Public endpoints:

Certificates are created for each public endpoint by default. However, custom certificates
can be specified by creating a secret with the following keys:

* `tls.crt`: The TLS certificate,
* `tls.key`: The corresponding private key for the TLS certificate,
* `ca.crt`: The CA certificate that has issued the TLS certificate,

The information is then used to be set the `Route` for this public endpoint or in future if a `LoadBalancer` service is used to terminated the endpoint at the pod level.
* An alternative would be to directly use the `RouteOverride` to set the cert, key and CA cert for the endpoint.

Example using the route override:

```yaml
apiVersion: core.openstack.org/v1beta1
kind: OpenStackControlPlane
metadata:
  name: myctlplane
spec:
  ...
  keystone:
    apiOverride:
      route:
        spec:
          tls:
            termination: edge
            certificate: |-
              -----BEGIN CERTIFICATE-----
              -----END CERTIFICATE-----
            key: |-
              -----BEGIN RSA PRIVATE KEY----
              -----END RSA PRIVATE KEY-----
            caCertificate: |-
              -----BEGIN CERTIFICATE-----
              -----END CERTIFICATE-----
            insecureEdgeTerminationPolicy: Redirect
```

For public endpoints, custom certificates can be specified within the `apiOverride` section for each service. This is not part of the global TLS configuration but is specific to each service that requires a custom public endpoint certificate.

Example of specifying custom certificates for `ingress` traffic:

```yaml
apiVersion: core.openstack.org/v1beta1
kind: OpenStackControlPlane
metadata:
  name: custom-ingress-cert-example
spec:
  ...
  keystone:
    apiOverride:
      tls:
        secretName: custom-ingress-cert-secret
    template:
  ...
```

#### Internal endpoints

For internal TLS, certificates are similarly managed with options for customization. CertManager issues certificates based on internal or public issuers, and the resulting secrets can be integrated into service configurations. To specify a custom certificates for internal endpoints, it's only possible providing the custom issuer.

## TLS common package 

The [lib-common common module tls package](https://github.com/openstack-k8s-operators/lib-common/tree/main/modules/common/tls) defines several structs to organize and apply TLS settings for different *service types* within the OpenStack deployment.

### Generic Service

The `GenericService` represents the basic configuration for a service requiring TLS. It includes the SecretName field, which refers to a Kubernetes secret containing the TLS certificate (tls.crt),private key (tls.key) and the CA certificate (ca.crt) used to sign the service certificate.

### Simple Service

The `SimpleService` extends the GenericService by including CA information through embedding the `Ca` struct. This allows for specifying a custom CA bundle secret `caBundleSecretName`.

Example of a single, not endpoint specific service:
```yaml
  tls:
    caBundleSecretName: combined-ca-bundle
    secretName: cert-nova-novncproxy-cell1-public-svc
```

### API Service

The `API` struct focuses on services that provide an API, which might have different TLS requirements for its public and internal endpoints. It includes:
* `APIService`: Encapsulates TLS configurations for both public and internal API endpoints.
* `Public`: A GenericService for the public (external) endpoint of the API.
* `Internal`: A GenericService for the internal endpoint of the API.

Example of a public/internal API service:
```yaml
  tls:
    api:
      # secret holding tls.crt and tls.key for the APIs internal k8s service
      internal:
        secretName: cert-internal-svc
      # secret holding tls.crt and tls.key for the APIs public k8s service
      public:
        secretName: cert-public-svc
    # secret holding the tls-ca-bundle.pem to be used as a deploymend env CA bundle
    caBundleSecretName: combined-ca-bundle
```

## Mounting the Certificates and Handling Certificate Updates

As mentioned above - certificates, including TLS certificates (`tls.crt`), private keys (`tls.key`), and CA certificates (`ca.crt`), are stored in secrets. These secrets are mounted into the containers of the services that require them. Depending on how the service gets started (using kolla or not), the cert and key get either mounted to a directory and using kolla to put into its final place, or directly mounted to where the service expects it. The CA bundle is always mounted as the global CA bundle to the final destination (bypassing kolla).

For k8s service a virtual host gets configured using the service name with its corresponding certificate.

Like with other config secrets and config maps, a hash is used to identify if the certificate changed and the deployment pod has to be restarted. For this, the service operators index the named secret fields to be able to watch those if they change. If a change is detected which results in a hash change, the default action is to restart the deployment in order to use the new certificates. There might be services which will handle this differently, but currently there's no option to put new certificates in use without restarting the deployment.

If internal tls is enabled, using `spec.tls.podlevel.enabled: true`, routes get configured with `spec.tls.termination: reencrypt` and CA added to `spec.tls.destinationCACertificate` to be able to validate the certificate of the k8s service.

## Deployments Using k8s Services

The configuration of the service is reflecting the k8s service name, not the individual pod name. With this all pods in a scaling resource will share the same service certificate. 

For each of the k8s services the openstack-operator requests a certificate for the hostname `<service>.<namespace>.svc` and `<service>.<namespace>.svc.cluster.local` using the internal and the public `CertManager` issuer. For each cert request, CertManger will create a secret holding a `tls.crt`, `tls.key` and `ca.crt`. Those secrets, certificate and the combined CA bundle described above, can be passed into the service operators CRD using the tls section.

## Deployments Not Using k8s Services

TBD when e.g. ovn got added

## Testing Scenarios

TBD
